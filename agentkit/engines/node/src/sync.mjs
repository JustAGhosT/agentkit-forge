/**
 * AgentKit Forge — Sync Command
 * Reads spec + overlay → renders templates → writes generated outputs
 */
import {
  readFileSync, writeFileSync, mkdirSync, existsSync, readdirSync,
  statSync, renameSync, rmSync, chmodSync, cpSync
} from 'fs';
import { resolve, join, relative, dirname, extname, basename, sep } from 'path';
import yaml from 'js-yaml';

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function readYaml(filePath) {
  if (!existsSync(filePath)) return null;
  return yaml.load(readFileSync(filePath, 'utf-8'));
}

function readText(filePath) {
  if (!existsSync(filePath)) return null;
  return readFileSync(filePath, 'utf-8');
}

/**
 * Renders a template by replacing {{key}} placeholders with values from vars.
 * - Replaces longest keys first to prevent partial matches (e.g., {{versionInfo}} before {{version}})
 * - Sanitizes string values to prevent shell metacharacter injection
 * - Warns on unresolved placeholders when DEBUG is set
 */
function renderTemplate(template, vars) {
  let result = template;
  // Sort keys longest-first to prevent partial placeholder collisions
  const sortedKeys = Object.keys(vars).sort((a, b) => b.length - a.length);
  for (const key of sortedKeys) {
    const value = vars[key];
    const placeholder = `{{${key}}}`;
    const safeValue = typeof value === 'string' ? sanitizeTemplateValue(value) : JSON.stringify(value);
    result = result.split(placeholder).join(safeValue);
  }
  // Warn about unresolved placeholders
  const unresolved = result.match(/\{\{[a-zA-Z_][a-zA-Z0-9_]*\}\}/g);
  if (unresolved && process.env.DEBUG) {
    const unique = [...new Set(unresolved)];
    console.warn(`[agentkit:sync] Warning: unresolved placeholders: ${unique.join(', ')}`);
  }
  return result;
}

/**
 * Sanitizes a template variable value to prevent injection.
 * Strips shell metacharacters that could cause command injection if the
 * rendered output is executed in a shell context (e.g., hook scripts).
 */
function sanitizeTemplateValue(value) {
  // Remove characters that enable shell injection: $() `` ; | & etc.
  // Allow common safe characters: alphanumeric, spaces, hyphens, underscores, dots, slashes, @
  return value.replace(/[`$\\;|&<>!{}()]/g, '');
}

function getGeneratedHeader(version, repoName, ext) {
  const comment = getCommentStyle(ext);
  if (!comment) return '';
  return [
    `${comment.start} GENERATED by AgentKit Forge v${version} — DO NOT EDIT ${comment.end}`,
    `${comment.start} Source: agentkit/spec + agentkit/overlays/${repoName} ${comment.end}`,
    `${comment.start} Regenerate: pnpm -C agentkit agentkit:sync ${comment.end}`,
    ''
  ].join('\n');
}

function getCommentStyle(ext) {
  switch (ext) {
    case '.md': case '.mdc': return { start: '<!--', end: '-->' };
    case '.json': case '.template': return null; // JSON / template files don't support comments
    case '.yml': case '.yaml': return { start: '#', end: '' };
    case '.sh': return { start: '#', end: '' };
    case '.ps1': return { start: '#', end: '' };
    case '': return { start: '#', end: '' }; // files like "cursorrules"
    default: return { start: '#', end: '' };
  }
}

function ensureDir(dirPath) {
  mkdirSync(dirPath, { recursive: true });
}

function writeOutput(filePath, content) {
  ensureDir(dirname(filePath));
  writeFileSync(filePath, content, 'utf-8');
}

function* walkDir(dir) {
  if (!existsSync(dir)) return;
  for (const entry of readdirSync(dir, { withFileTypes: true })) {
    const full = join(dir, entry.name);
    if (entry.isDirectory()) {
      yield* walkDir(full);
    } else {
      yield full;
    }
  }
}

// ---------------------------------------------------------------------------
// Core sync logic
// ---------------------------------------------------------------------------

export async function runSync({ agentkitRoot, projectRoot, flags }) {
  console.log('[agentkit:sync] Starting sync...');

  // 1. Load spec — version from package.json (primary) with VERSION file as fallback
  let version = '0.0.0';
  try {
    const pkg = JSON.parse(readFileSync(resolve(agentkitRoot, 'package.json'), 'utf-8'));
    version = pkg.version || version;
  } catch {
    version = readText(resolve(agentkitRoot, 'spec', 'VERSION'))?.trim() || version;
  }
  const teamsSpec = readYaml(resolve(agentkitRoot, 'spec', 'teams.yaml')) || {};
  const commandsSpec = readYaml(resolve(agentkitRoot, 'spec', 'commands.yaml')) || {};
  const rulesSpec = readYaml(resolve(agentkitRoot, 'spec', 'rules.yaml')) || {};
  const settingsSpec = readYaml(resolve(agentkitRoot, 'spec', 'settings.yaml')) || {};
  const agentsSpec = readYaml(resolve(agentkitRoot, 'spec', 'agents.yaml')) || {};
  const docsSpec = readYaml(resolve(agentkitRoot, 'spec', 'docs.yaml')) || {};

  // 2. Detect overlay
  let repoName = flags?.overlay;
  if (!repoName) {
    const markerPath = resolve(projectRoot, '.agentkit-repo');
    if (existsSync(markerPath)) {
      repoName = readText(markerPath).trim();
    }
  }
  if (!repoName) {
    repoName = '__TEMPLATE__';
    console.log('[agentkit:sync] No overlay detected, using __TEMPLATE__');
  }

  // 3. Load overlay
  const overlayDir = resolve(agentkitRoot, 'overlays', repoName);
  const overlaySettings = readYaml(resolve(overlayDir, 'settings.yaml')) || {};

  // Merge settings (data-level: union allow, union deny, deny wins)
  const mergedPermissions = mergePermissions(
    settingsSpec.permissions || {},
    overlaySettings.permissions || {}
  );

  // Template variables
  const vars = {
    version,
    repoName: overlaySettings.repoName || repoName,
    defaultBranch: overlaySettings.defaultBranch || 'main',
    primaryStack: overlaySettings.primaryStack || 'auto',
  };

  console.log(`[agentkit:sync] Repo: ${vars.repoName}, Version: ${version}`);

  // 4. Render templates to temp directory
  const tmpDir = resolve(agentkitRoot, '.tmp');
  rmSync(tmpDir, { recursive: true, force: true });
  mkdirSync(tmpDir, { recursive: true });

  const templatesDir = resolve(agentkitRoot, 'templates');

  // --- Claude templates ---
  syncDirectCopy(templatesDir, 'claude/hooks', tmpDir, '.claude/hooks', vars, version, repoName);
  syncClaudeSettings(templatesDir, tmpDir, vars, version, mergedPermissions, settingsSpec);
  syncClaudeCommands(templatesDir, tmpDir, vars, version, repoName, teamsSpec, commandsSpec);
  syncClaudeAgents(templatesDir, tmpDir, vars, version, repoName, agentsSpec);
  syncDirectCopy(templatesDir, 'claude/rules', tmpDir, '.claude/rules', vars, version, repoName);
  syncDirectCopy(templatesDir, 'claude/state', tmpDir, '.claude/state', vars, version, repoName);

  // --- Cursor templates ---
  syncDirectCopy(templatesDir, 'cursor/rules', tmpDir, '.cursor/rules', vars, version, repoName);
  syncCursorTeams(tmpDir, vars, version, repoName, teamsSpec);

  // --- Windsurf templates ---
  syncDirectCopy(templatesDir, 'windsurf/rules', tmpDir, '.windsurf/rules', vars, version, repoName);
  syncDirectCopy(templatesDir, 'windsurf/workflows', tmpDir, '.windsurf/workflows', vars, version, repoName);
  syncWindsurfTeams(tmpDir, vars, version, repoName, teamsSpec);

  // --- .ai templates ---
  syncDirectCopy(templatesDir, 'ai', tmpDir, '.ai', vars, version, repoName);

  // --- Copilot templates ---
  syncCopilot(templatesDir, tmpDir, vars, version, repoName);

  // --- MCP templates ---
  syncDirectCopy(templatesDir, 'mcp', tmpDir, 'mcp', vars, version, repoName);

  // --- GitHub templates ---
  syncGitHub(templatesDir, tmpDir, vars, version, repoName);

  // --- Root docs ---
  syncRootDocs(templatesDir, tmpDir, vars, version, repoName);

  // --- Claude.md (special: goes to project root) ---
  syncClaudeMd(templatesDir, tmpDir, vars, version, repoName);

  // --- Docs structure ---
  syncDirectCopy(templatesDir, 'docs', tmpDir, 'docs', vars, version, repoName);

  // --- VS Code + editor configs ---
  syncDirectCopy(templatesDir, 'vscode', tmpDir, '.vscode', vars, version, repoName);
  syncEditorConfigs(templatesDir, tmpDir, vars, version, repoName);

  // 5. Atomic swap: move temp outputs to project root
  console.log('[agentkit:sync] Writing outputs...');
  const resolvedRoot = resolve(projectRoot) + sep;
  let count = 0;
  const failedFiles = [];
  for (const srcFile of walkDir(tmpDir)) {
    const relPath = relative(tmpDir, srcFile);
    const destFile = resolve(projectRoot, relPath);

    // Path traversal protection: ensure all output stays within project root
    if (!resolve(destFile).startsWith(resolvedRoot) && resolve(destFile) !== resolve(projectRoot)) {
      console.error(`[agentkit:sync] BLOCKED: path traversal detected — ${relPath}`);
      failedFiles.push({ file: relPath, error: 'path traversal blocked' });
      continue;
    }

    try {
      ensureDir(dirname(destFile));
      cpSync(srcFile, destFile, { force: true });

      // Make .sh files executable
      if (extname(srcFile) === '.sh') {
        try { chmodSync(destFile, 0o755); } catch { /* ignore on Windows */ }
      }
      count++;
    } catch (err) {
      failedFiles.push({ file: relPath, error: err.message });
      console.error(`[agentkit:sync] Failed to write: ${relPath} — ${err.message}`);
    }
  }

  // 6. Cleanup temp
  rmSync(tmpDir, { recursive: true, force: true });

  if (failedFiles.length > 0) {
    console.error(`[agentkit:sync] Warning: ${failedFiles.length} file(s) failed to write.`);
  }
  console.log(`[agentkit:sync] Done! Generated ${count} files.`);
}

// ---------------------------------------------------------------------------
// Sync helpers
// ---------------------------------------------------------------------------

function mergePermissions(base, overlay) {
  const allow = [...new Set([...(base.allow || []), ...(overlay.allow || [])])];
  const deny = [...new Set([...(base.deny || []), ...(overlay.deny || [])])];
  return { allow, deny };
}

function syncDirectCopy(templatesDir, srcSubdir, tmpDir, destSubdir, vars, version, repoName) {
  const srcDir = resolve(templatesDir, srcSubdir);
  if (!existsSync(srcDir)) return;

  for (const file of walkDir(srcDir)) {
    const relPath = relative(srcDir, file);
    const destPath = resolve(tmpDir, destSubdir, relPath);
    const ext = extname(file);

    let content = readFileSync(file, 'utf-8');
    content = renderTemplate(content, { ...vars, repoName });

    // Add generated header for non-JSON, non-gitkeep files
    if (ext !== '.json' && basename(file) !== '.gitkeep') {
      content = insertHeader(content, ext, version, repoName);
    }

    writeOutput(destPath, content);
  }
}

/**
 * Inserts the GENERATED header into content, respecting shebangs and frontmatter.
 * - .sh/.ps1 files with shebang: header goes after shebang line
 * - .md/.mdc files with YAML frontmatter: header goes after closing ---
 * - Skips if content already contains "GENERATED by AgentKit Forge"
 */
function insertHeader(content, ext, version, repoName) {
  if (content.includes('GENERATED by AgentKit Forge')) return content;
  const header = getGeneratedHeader(version, repoName, ext);
  if (!header) return content;

  // Shell scripts: insert after shebang line
  if ((ext === '.sh' || ext === '.ps1') && content.startsWith('#!')) {
    const firstNewline = content.indexOf('\n');
    if (firstNewline > -1) {
      return content.substring(0, firstNewline + 1) + header + content.substring(firstNewline + 1);
    }
  }

  // Markdown/mdc with YAML frontmatter: insert after closing ---
  if ((ext === '.md' || ext === '.mdc') && content.startsWith('---')) {
    const closingIdx = content.indexOf('\n---', 3);
    if (closingIdx > -1) {
      const endOfFrontmatter = content.indexOf('\n', closingIdx + 4);
      if (endOfFrontmatter > -1) {
        return content.substring(0, endOfFrontmatter + 1) + '\n' + header + content.substring(endOfFrontmatter + 1);
      }
      // Frontmatter closing --- is at EOF — append header after it
      return content + '\n' + header;
    }
  }

  return header + content;
}

function syncClaudeSettings(templatesDir, tmpDir, vars, version, mergedPermissions, settingsSpec) {
  const templatePath = resolve(templatesDir, 'claude', 'settings.json');
  if (!existsSync(templatePath)) {
    console.warn('[agentkit:sync] Warning: claude/settings.json template not found');
    return;
  }

  let template = readFileSync(templatePath, 'utf-8');
  // The settings.json template has placeholder arrays — replace with merged permissions
  const settings = JSON.parse(renderTemplate(template, vars));

  // Override permissions with merged values
  if (settings.permissions) {
    settings.permissions.allow = mergedPermissions.allow;
    settings.permissions.deny = mergedPermissions.deny;
  }

  const destPath = resolve(tmpDir, '.claude', 'settings.json');
  writeOutput(destPath, JSON.stringify(settings, null, 2) + '\n');
}

function syncClaudeCommands(templatesDir, tmpDir, vars, version, repoName, teamsSpec, commandsSpec) {
  const commandsDir = resolve(templatesDir, 'claude', 'commands');
  if (!existsSync(commandsDir)) return;

  // Copy all non-TEMPLATE command files
  const files = readdirSync(commandsDir);
  for (const file of files) {
    if (file === 'team-TEMPLATE.md') continue;
    const srcPath = resolve(commandsDir, file);
    if (statSync(srcPath).isDirectory()) continue;

    let content = readFileSync(srcPath, 'utf-8');
    content = renderTemplate(content, { ...vars, repoName });
    content = insertHeader(content, extname(file), version, repoName);
    writeOutput(resolve(tmpDir, '.claude', 'commands', file), content);
  }

  // Generate team commands from template
  const teamTemplatePath = resolve(commandsDir, 'team-TEMPLATE.md');
  if (existsSync(teamTemplatePath) && teamsSpec.teams) {
    const teamTemplate = readFileSync(teamTemplatePath, 'utf-8');

    for (const team of teamsSpec.teams) {
      const teamVars = {
        ...vars,
        teamId: team.id,
        teamName: team.name,
        teamFocus: team.focus,
        teamScope: Array.isArray(team.scope) ? team.scope.join(', ') : (team.scope || '**/*'),
      };

      let content = renderTemplate(teamTemplate, teamVars);
      content = insertHeader(content, '.md', version, repoName);
      const fileName = `team-${team.id}.md`;
      writeOutput(resolve(tmpDir, '.claude', 'commands', fileName), content);
    }
  }
}

function syncClaudeAgents(templatesDir, tmpDir, vars, version, repoName, agentsSpec) {
  const agentTemplatePath = resolve(templatesDir, 'claude', 'agents', 'TEMPLATE.md');
  if (!existsSync(agentTemplatePath) || !agentsSpec.agents) return;

  const agentTemplate = readFileSync(agentTemplatePath, 'utf-8');

  // agents.yaml has nested structure: agents.engineering: [...], agents.design: [...], etc.
  // Flatten all agents from all categories
  const allAgents = [];
  for (const [category, agents] of Object.entries(agentsSpec.agents)) {
    if (!Array.isArray(agents)) continue;
    for (const agent of agents) {
      allAgents.push({ ...agent, category: agent.category || category });
    }
  }

  for (const agent of allAgents) {
    const focusList = Array.isArray(agent.focus)
      ? agent.focus.map(f => `- \`${f}\``).join('\n') : (agent.focus || '');
    const responsibilitiesList = Array.isArray(agent.responsibilities)
      ? agent.responsibilities.map(r => `- ${r}`).join('\n') : (agent.responsibilities || '');
    const toolsList = Array.isArray(agent['preferred-tools'])
      ? agent['preferred-tools'].map(t => `- ${t}`).join('\n')
      : (Array.isArray(agent.tools) ? agent.tools.map(t => `- ${t}`).join('\n') : '');

    const agentVars = {
      ...vars,
      agentId: agent.id,
      agentCategory: agent.category,
      agentName: agent.name,
      agentRole: agent.role || '',
      agentFocusList: focusList,
      agentResponsibilitiesList: responsibilitiesList,
      agentToolsList: toolsList,
    };

    let content = renderTemplate(agentTemplate, agentVars);
    content = insertHeader(content, '.md', version, repoName);
    const destPath = resolve(tmpDir, '.claude', 'agents', agent.category, `${agent.id}.md`);
    writeOutput(destPath, content);
  }
}

function syncCopilot(templatesDir, tmpDir, vars, version, repoName) {
  // Main copilot instructions
  const mainPath = resolve(templatesDir, 'copilot', 'copilot-instructions.md');
  if (existsSync(mainPath)) {
    let content = readFileSync(mainPath, 'utf-8');
    content = renderTemplate(content, { ...vars, repoName });
    content = insertHeader(content, '.md', version, repoName);
    writeOutput(resolve(tmpDir, '.github', 'copilot-instructions.md'), content);
  }

  // Path-specific instructions
  const instrDir = resolve(templatesDir, 'copilot', 'instructions');
  if (existsSync(instrDir)) {
    syncDirectCopy(templatesDir, 'copilot/instructions', tmpDir, '.github/instructions', vars, version, repoName);
  }
}

function syncGitHub(templatesDir, tmpDir, vars, version, repoName) {
  const githubDir = resolve(templatesDir, 'github');
  if (!existsSync(githubDir)) return;

  // CI workflow
  const ciPath = resolve(githubDir, 'ai-framework-ci.yml');
  if (existsSync(ciPath)) {
    let content = readFileSync(ciPath, 'utf-8');
    content = renderTemplate(content, { ...vars, repoName });
    content = insertHeader(content, '.yml', version, repoName);
    writeOutput(resolve(tmpDir, '.github', 'workflows', 'ai-framework-ci.yml'), content);
  }

  // Issue template
  const issueDir = resolve(githubDir, 'ISSUE_TEMPLATE');
  if (existsSync(issueDir)) {
    syncDirectCopy(templatesDir, 'github/ISSUE_TEMPLATE', tmpDir, '.github/ISSUE_TEMPLATE', vars, version, repoName);
  }

  // PR template
  const prPath = resolve(githubDir, 'PULL_REQUEST_TEMPLATE.md');
  if (existsSync(prPath)) {
    let content = readFileSync(prPath, 'utf-8');
    content = renderTemplate(content, { ...vars, repoName });
    content = insertHeader(content, '.md', version, repoName);
    writeOutput(resolve(tmpDir, '.github', 'PULL_REQUEST_TEMPLATE.md'), content);
  }
}

function syncRootDocs(templatesDir, tmpDir, vars, version, repoName) {
  const rootDir = resolve(templatesDir, 'root');
  if (!existsSync(rootDir)) return;

  const files = readdirSync(rootDir);
  for (const file of files) {
    const srcPath = resolve(rootDir, file);
    if (statSync(srcPath).isDirectory()) continue;

    let content = readFileSync(srcPath, 'utf-8');
    content = renderTemplate(content, { ...vars, repoName });
    const ext = extname(file);
    content = insertHeader(content, ext, version, repoName);
    writeOutput(resolve(tmpDir, file), content);
  }
}

function syncClaudeMd(templatesDir, tmpDir, vars, version, repoName) {
  const claudeMdPath = resolve(templatesDir, 'claude', 'CLAUDE.md');
  if (!existsSync(claudeMdPath)) return;

  let content = readFileSync(claudeMdPath, 'utf-8');
  content = renderTemplate(content, { ...vars, repoName });
  content = insertHeader(content, '.md', version, repoName);
  writeOutput(resolve(tmpDir, 'CLAUDE.md'), content);
}

function syncEditorConfigs(templatesDir, tmpDir, vars, version, repoName) {
  // .editorconfig, .prettierrc, .markdownlint.json — look in templates/root or templates/ root-level
  const configs = [
    { src: 'root/.editorconfig', dest: '.editorconfig' },
    { src: 'root/.prettierrc', dest: '.prettierrc' },
    { src: 'root/.markdownlint.json', dest: '.markdownlint.json' },
  ];

  for (const cfg of configs) {
    const srcPath = resolve(templatesDir, cfg.src);
    if (!existsSync(srcPath)) continue;

    let content = readFileSync(srcPath, 'utf-8');
    content = renderTemplate(content, { ...vars, repoName });
    const ext = extname(cfg.dest);

    // JSON files don't get headers
    if (ext !== '.json') {
      const header = getGeneratedHeader(version, repoName, ext);
      if (header) content = header + content;
    }

    writeOutput(resolve(tmpDir, cfg.dest), content);
  }
}

function syncCursorTeams(tmpDir, vars, version, repoName, teamsSpec) {
  if (!teamsSpec.teams) return;

  for (const team of teamsSpec.teams) {
    const scope = Array.isArray(team.scope) ? team.scope.join(', ') : (team.scope || '**/*');
    const globs = Array.isArray(team.scope) ? team.scope.join(', ') : '';
    let content = [
      '---',
      `description: "Team ${team.name} — ${team.focus}"`,
      `globs: ${globs}`,
      'alwaysApply: false',
      '---',
      `# Team: ${team.name}`,
      '',
      `**Focus**: ${team.focus}`,
      `**Scope**: ${scope}`,
      '',
      '## Responsibilities',
      `- Own all code within scope: ${scope}`,
      '- Follow project conventions and quality gates',
      '- Coordinate with other teams via /orchestrate for cross-cutting changes',
      '',
      '## Workflow',
      '1. Review current backlog in AGENT_BACKLOG.md',
      '2. Implement changes within team scope',
      '3. Run /check before committing',
      '4. Use /handoff when passing work to another team',
      '',
    ].join('\n');

    content = renderTemplate(content, { ...vars, repoName });
    content = insertHeader(content, '.mdc', version, repoName);
    const fileName = `team-${team.id}.mdc`;
    writeOutput(resolve(tmpDir, '.cursor', 'rules', fileName), content);
  }
}

function syncWindsurfTeams(tmpDir, vars, version, repoName, teamsSpec) {
  if (!teamsSpec.teams) return;

  for (const team of teamsSpec.teams) {
    const scope = Array.isArray(team.scope) ? team.scope.join(', ') : (team.scope || '**/*');
    let content = [
      `# Team: ${team.name}`,
      '',
      `**Focus**: ${team.focus}`,
      `**Scope**: ${scope}`,
      '',
      '## Responsibilities',
      `- Own all code within scope: ${scope}`,
      '- Follow project conventions and quality gates',
      '- Coordinate with other teams via /orchestrate for cross-cutting changes',
      '',
      '## Workflow',
      '1. Review current backlog in AGENT_BACKLOG.md',
      '2. Implement changes within team scope',
      '3. Run /check before committing',
      '4. Use /handoff when passing work to another team',
      '',
    ].join('\n');

    content = renderTemplate(content, { ...vars, repoName });
    content = insertHeader(content, '.md', version, repoName);
    const fileName = `team-${team.id}.md`;
    writeOutput(resolve(tmpDir, '.windsurf', 'rules', fileName), content);
  }
}

// ---------------------------------------------------------------------------
// Exports for testing
// ---------------------------------------------------------------------------
export { renderTemplate, sanitizeTemplateValue, getCommentStyle, getGeneratedHeader, mergePermissions, insertHeader };
