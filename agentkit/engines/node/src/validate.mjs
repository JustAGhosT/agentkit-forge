/**
 * AgentKit Forge — Validate Command
 * Validates generated outputs for correctness.
 */
import { readFileSync, existsSync, readdirSync, statSync } from 'fs';
import { resolve, join, extname } from 'path';

export async function runValidate({ agentkitRoot, projectRoot, flags }) {
  console.log('[agentkit:validate] Validating generated outputs...');
  let errors = 0;
  let warnings = 0;

  // 1. Check required directories exist
  const requiredDirs = [
    '.claude/commands',
    '.claude/hooks',
    '.claude/state',
    '.claude/rules',
    '.claude/agents',
    '.cursor/rules',
    '.windsurf/rules',
    '.ai',
    'docs',
  ];

  for (const dir of requiredDirs) {
    const fullPath = resolve(projectRoot, dir);
    if (!existsSync(fullPath)) {
      console.error(`  FAIL: Missing directory: ${dir}`);
      errors++;
    } else {
      console.log(`  OK: ${dir}`);
    }
  }

  // 2. Validate JSON files
  const jsonFiles = [
    '.claude/settings.json',
    '.claude/state/schema.json',
    '.claude/state/orchestrator.json.template',
    'mcp/servers.json',
    'mcp/a2a-config.json',
  ];

  for (const file of jsonFiles) {
    const fullPath = resolve(projectRoot, file);
    if (!existsSync(fullPath)) {
      console.error(`  FAIL: Missing JSON file: ${file}`);
      errors++;
      continue;
    }
    try {
      JSON.parse(readFileSync(fullPath, 'utf-8'));
      console.log(`  OK: ${file} (valid JSON)`);
    } catch (err) {
      console.error(`  FAIL: ${file} — invalid JSON: ${err.message}`);
      errors++;
    }
  }

  // 3. Check required command files
  const requiredCommands = [
    'orchestrate', 'discover', 'healthcheck', 'review', 'sync-backlog',
    'check', 'plan', 'handoff', 'build', 'test', 'format', 'deploy', 'security',
    'team-backend', 'team-frontend', 'team-data', 'team-infra', 'team-devops',
    'team-testing', 'team-security', 'team-docs', 'team-product', 'team-quality',
  ];

  for (const cmd of requiredCommands) {
    const fullPath = resolve(projectRoot, '.claude', 'commands', `${cmd}.md`);
    if (!existsSync(fullPath)) {
      console.error(`  FAIL: Missing command: .claude/commands/${cmd}.md`);
      errors++;
    }
  }
  console.log(`  Checked ${requiredCommands.length} commands`);

  // 4. Check hook files exist (both .sh and .ps1)
  const requiredHooks = [
    'session-start', 'protect-sensitive', 'guard-destructive-commands',
    'warn-uncommitted', 'stop-build-check',
  ];

  for (const hook of requiredHooks) {
    for (const ext of ['.sh', '.ps1']) {
      const fullPath = resolve(projectRoot, '.claude', 'hooks', `${hook}${ext}`);
      if (!existsSync(fullPath)) {
        console.error(`  FAIL: Missing hook: .claude/hooks/${hook}${ext}`);
        errors++;
      }
    }
  }
  console.log(`  Checked ${requiredHooks.length} hooks (sh + ps1)`);

  // 5. Check for generated header in markdown files
  const sampleFiles = [
    '.claude/commands/orchestrate.md',
    'CLAUDE.md',
    'UNIFIED_AGENT_TEAMS.md',
  ];

  for (const file of sampleFiles) {
    const fullPath = resolve(projectRoot, file);
    if (!existsSync(fullPath)) continue;
    const content = readFileSync(fullPath, 'utf-8');
    if (!content.includes('GENERATED by AgentKit Forge')) {
      console.warn(`  WARN: ${file} missing GENERATED header`);
      warnings++;
    }
  }

  // 6. Check settings.json has correct hooks format
  const settingsPath = resolve(projectRoot, '.claude', 'settings.json');
  if (existsSync(settingsPath)) {
    try {
      const settings = JSON.parse(readFileSync(settingsPath, 'utf-8'));
      if (!settings.hooks) {
        console.error('  FAIL: settings.json missing hooks configuration');
        errors++;
      } else {
        // Verify hooks use nested array format
        for (const [event, matchers] of Object.entries(settings.hooks)) {
          if (!Array.isArray(matchers)) {
            console.error(`  FAIL: settings.json hooks.${event} should be an array`);
            errors++;
          }
        }
      }
      if (!settings.permissions?.allow?.length) {
        console.warn('  WARN: settings.json has empty allow list');
        warnings++;
      }
    } catch { /* already reported above */ }
  }

  // 7. Scan for forbidden patterns
  console.log('  Scanning for forbidden patterns...');
  const sensitivePatterns = [
    /password\s*[:=]\s*["'][^"']+["']/i,
    /api[_-]?key\s*[:=]\s*["'][^"']+["']/i,
    /secret\s*[:=]\s*["'][A-Za-z0-9+/=]{20,}["']/i,
  ];

  const generatedDirs = ['.claude', '.cursor', '.windsurf', '.ai', 'docs'];
  for (const dir of generatedDirs) {
    const fullDir = resolve(projectRoot, dir);
    if (!existsSync(fullDir)) continue;
    scanForPatterns(fullDir, sensitivePatterns, (file, pattern) => {
      console.error(`  FAIL: Forbidden pattern in ${file}: ${pattern}`);
      errors++;
    });
  }

  // Summary
  console.log('');
  if (errors > 0) {
    console.error(`[agentkit:validate] FAILED: ${errors} error(s), ${warnings} warning(s)`);
    process.exit(1);
  } else {
    console.log(`[agentkit:validate] PASSED: ${warnings} warning(s)`);
  }
}

function scanForPatterns(dir, patterns, onMatch) {
  if (!existsSync(dir)) return;
  for (const entry of readdirSync(dir, { withFileTypes: true })) {
    const full = join(dir, entry.name);
    if (entry.isDirectory()) {
      scanForPatterns(full, patterns, onMatch);
    } else {
      const ext = extname(entry.name);
      // Only scan text files
      if (['.md', '.json', '.yaml', '.yml', '.sh', '.ps1', '.mdc', ''].includes(ext)) {
        try {
          const content = readFileSync(full, 'utf-8');
          for (const pattern of patterns) {
            if (pattern.test(content)) {
              onMatch(full, pattern.toString());
            }
          }
        } catch { /* skip unreadable files */ }
      }
    }
  }
}
