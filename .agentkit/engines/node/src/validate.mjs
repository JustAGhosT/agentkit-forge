/**
 * AgentKit Forge — Validate Command
 * Validates generated outputs for correctness.
 * Now includes spec-aware validation via spec-validator.mjs.
 */
import { readFileSync, existsSync, readdirSync, statSync } from 'fs';
import { resolve, join, extname } from 'path';
import { validateSpec } from './spec-validator.mjs';

export async function runValidate({ agentkitRoot, projectRoot, flags }) {
  console.log('[agentkit:validate] Validating generated outputs...');
  let errors = 0;
  let warnings = 0;

  // ─── Phase 1: Validate spec files ──────────────────────────────────────
  console.log('\n  --- Spec Validation ---');
  const specResult = validateSpec(agentkitRoot);
  for (const err of specResult.errors) {
    console.error(`  FAIL: [spec] ${err}`);
    errors++;
  }
  for (const warn of specResult.warnings) {
    console.warn(`  WARN: [spec] ${warn}`);
    warnings++;
  }
  if (specResult.valid) {
    console.log('  OK: All spec files pass schema validation');
  }

  // ─── Phase 2: Check required directories ───────────────────────────────
  console.log('\n  --- Output Directories ---');
  const requiredDirs = [
    '.claude/commands',
    '.claude/hooks',
    '.claude/state',
    '.claude/rules',
    '.claude/agents',
    '.cursor/rules',
    '.windsurf/rules',
    '.ai',
    'docs',
  ];

  for (const dir of requiredDirs) {
    const fullPath = resolve(projectRoot, dir);
    if (!existsSync(fullPath)) {
      console.error(`  FAIL: Missing directory: ${dir}`);
      errors++;
    } else {
      console.log(`  OK: ${dir}`);
    }
  }

  // ─── Phase 3: Validate JSON files ──────────────────────────────────────
  console.log('\n  --- JSON Files ---');
  const jsonFiles = [
    '.claude/settings.json',
    '.claude/state/schema.json',
    'mcp/servers.json',
    'mcp/a2a-config.json',
  ];

  for (const file of jsonFiles) {
    const fullPath = resolve(projectRoot, file);
    if (!existsSync(fullPath)) {
      console.error(`  FAIL: Missing JSON file: ${file}`);
      errors++;
      continue;
    }
    try {
      JSON.parse(readFileSync(fullPath, 'utf-8'));
      console.log(`  OK: ${file} (valid JSON)`);
    } catch (err) {
      console.error(`  FAIL: ${file} — invalid JSON: ${err.message}`);
      errors++;
    }
  }

  // ─── Phase 4: Check command files match spec ───────────────────────────
  console.log('\n  --- Commands ---');
  const requiredCommands = [
    'orchestrate', 'discover', 'healthcheck', 'review', 'sync-backlog',
    'check', 'plan', 'handoff', 'build', 'test', 'format', 'deploy', 'security',
    'project-review',
    'team-backend', 'team-frontend', 'team-data', 'team-infra', 'team-devops',
    'team-testing', 'team-security', 'team-docs', 'team-product', 'team-quality',
  ];

  let commandsOk = 0;
  for (const cmd of requiredCommands) {
    const fullPath = resolve(projectRoot, '.claude', 'commands', `${cmd}.md`);
    if (!existsSync(fullPath)) {
      console.error(`  FAIL: Missing command: .claude/commands/${cmd}.md`);
      errors++;
    } else {
      commandsOk++;
    }
  }
  console.log(`  Checked ${requiredCommands.length} commands (${commandsOk} present)`);

  // ─── Phase 5: Check hook files ─────────────────────────────────────────
  console.log('\n  --- Hooks ---');
  const requiredHooks = [
    'session-start', 'protect-sensitive', 'guard-destructive-commands',
    'warn-uncommitted', 'stop-build-check',
  ];

  for (const hook of requiredHooks) {
    for (const ext of ['.sh', '.ps1']) {
      const fullPath = resolve(projectRoot, '.claude', 'hooks', `${hook}${ext}`);
      if (!existsSync(fullPath)) {
        console.error(`  FAIL: Missing hook: .claude/hooks/${hook}${ext}`);
        errors++;
      }
    }
  }
  console.log(`  Checked ${requiredHooks.length} hooks (sh + ps1)`);

  // ─── Phase 6: Check generated headers ──────────────────────────────────
  console.log('\n  --- Generated Headers ---');
  const sampleFiles = [
    '.claude/commands/orchestrate.md',
    'CLAUDE.md',
    'UNIFIED_AGENT_TEAMS.md',
  ];

  for (const file of sampleFiles) {
    const fullPath = resolve(projectRoot, file);
    if (!existsSync(fullPath)) continue;
    const content = readFileSync(fullPath, 'utf-8');
    if (!content.includes('GENERATED by AgentKit Forge')) {
      console.warn(`  WARN: ${file} missing GENERATED header`);
      warnings++;
    } else {
      console.log(`  OK: ${file} has GENERATED header`);
    }
  }

  // ─── Phase 7: Check settings.json structure ────────────────────────────
  console.log('\n  --- Settings ---');
  const settingsPath = resolve(projectRoot, '.claude', 'settings.json');
  if (existsSync(settingsPath)) {
    try {
      const settings = JSON.parse(readFileSync(settingsPath, 'utf-8'));
      if (!settings.hooks) {
        console.error('  FAIL: settings.json missing hooks configuration');
        errors++;
      } else {
        // Verify hooks use nested array format
        for (const [event, matchers] of Object.entries(settings.hooks)) {
          if (!Array.isArray(matchers)) {
            console.error(`  FAIL: settings.json hooks.${event} should be an array`);
            errors++;
          }
        }
        console.log('  OK: settings.json hooks structure');
      }
      if (!settings.permissions?.allow?.length) {
        console.warn('  WARN: settings.json has empty allow list');
        warnings++;
      } else {
        console.log(`  OK: settings.json has ${settings.permissions.allow.length} allow rules`);
      }
    } catch { /* already reported above */ }
  }

  // ─── Phase 8: Scan for forbidden patterns ──────────────────────────────
  console.log('\n  --- Secret Scan ---');
  const sensitivePatterns = [
    /password\s*[:=]\s*["'][^"']+["']/i,
    /api[_-]?key\s*[:=]\s*["'][^"']+["']/i,
    /secret\s*[:=]\s*["'][A-Za-z0-9+/=]{20,}["']/i,
    /AKIA[0-9A-Z]{16}/,  // AWS access key pattern
    /ghp_[A-Za-z0-9]{36}/, // GitHub personal access token
    /sk-[A-Za-z0-9]{48}/, // OpenAI/Anthropic-style API key
  ];

  let scannedFiles = 0;
  const generatedDirs = ['.claude', '.cursor', '.windsurf', '.ai', 'docs'];
  for (const dir of generatedDirs) {
    const fullDir = resolve(projectRoot, dir);
    if (!existsSync(fullDir)) continue;
    scanForPatterns(fullDir, sensitivePatterns, (file, pattern) => {
      console.error(`  FAIL: Forbidden pattern in ${file}: ${pattern}`);
      errors++;
    }, (count) => { scannedFiles += count; });
  }
  console.log(`  Scanned ${scannedFiles} files for secrets`);

  // ─── Summary ───────────────────────────────────────────────────────────
  console.log('');
  if (errors > 0) {
    console.error(`[agentkit:validate] FAILED: ${errors} error(s), ${warnings} warning(s)`);
    process.exit(1);
  } else {
    console.log(`[agentkit:validate] PASSED: ${warnings} warning(s)`);
  }
}

function scanForPatterns(dir, patterns, onMatch, onCount) {
  if (!existsSync(dir)) return;
  let count = 0;
  for (const entry of readdirSync(dir, { withFileTypes: true })) {
    const full = join(dir, entry.name);
    if (entry.isDirectory()) {
      scanForPatterns(full, patterns, onMatch, onCount);
    } else {
      const ext = extname(entry.name);
      // Only scan text files
      if (['.md', '.json', '.yaml', '.yml', '.sh', '.ps1', '.mdc', ''].includes(ext)) {
        count++;
        try {
          let content = readFileSync(full, 'utf-8');
          // Strip code blocks and inline code to avoid false positives from documentation examples
          content = content.replace(/```[\s\S]*?```/g, '').replace(/`[^`]+`/g, '');
          for (const pattern of patterns) {
            if (pattern.test(content)) {
              onMatch(full, pattern.toString());
            }
          }
        } catch { /* skip unreadable files */ }
      }
    }
  }
  if (onCount) onCount(count);
}
