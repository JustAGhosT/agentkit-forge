import { describe, it, expect } from 'vitest';
import {
  renderTemplate,
  sanitizeTemplateValue,
  getCommentStyle,
  getGeneratedHeader,
  mergePermissions,
  insertHeader,
  isScaffoldOnce,
  evalTruthy,
  resolveConditionals,
  resolveEachBlocks,
  flattenProjectYaml,
  flattenCrosscutting,
} from '../sync.mjs';

// ---------------------------------------------------------------------------
// renderTemplate
// ---------------------------------------------------------------------------
describe('renderTemplate', () => {
  it('replaces simple placeholders', () => {
    const result = renderTemplate('Hello {{name}}!', { name: 'World' });
    expect(result).toBe('Hello World!');
  });

  it('replaces multiple placeholders', () => {
    const result = renderTemplate('{{a}} and {{b}}', { a: '1', b: '2' });
    expect(result).toBe('1 and 2');
  });

  it('replaces longest keys first to prevent partial collisions', () => {
    const result = renderTemplate('{{version}} {{versionInfo}}', {
      version: '1.0',
      versionInfo: 'v1.0-beta',
    });
    expect(result).toBe('1.0 v1.0-beta');
  });

  it('serialises non-string values as JSON', () => {
    const result = renderTemplate('items: {{list}}', { list: ['a', 'b'] });
    expect(result).toBe('items: ["a","b"]');
  });

  it('leaves unresolved placeholders intact', () => {
    const result = renderTemplate('{{known}} {{unknown}}', { known: 'yes' });
    expect(result).toContain('{{unknown}}');
  });

  it('handles empty vars object', () => {
    const result = renderTemplate('no vars here', {});
    expect(result).toBe('no vars here');
  });

  it('handles empty template', () => {
    const result = renderTemplate('', { key: 'value' });
    expect(result).toBe('');
  });
});

// ---------------------------------------------------------------------------
// sanitizeTemplateValue
// ---------------------------------------------------------------------------
describe('sanitizeTemplateValue', () => {
  it('preserves safe characters', () => {
    expect(sanitizeTemplateValue('my-project_v2.0')).toBe('my-project_v2.0');
  });

  it('strips shell injection characters', () => {
    expect(sanitizeTemplateValue('$(rm -rf /)')).toBe('rm -rf /');
  });

  it('strips backtick injection', () => {
    expect(sanitizeTemplateValue('`whoami`')).toBe('whoami');
  });

  it('strips pipe and semicolons', () => {
    expect(sanitizeTemplateValue('name; echo pwned | cat')).toBe('name echo pwned  cat');
  });

  it('preserves spaces, slashes, and @ symbols', () => {
    expect(sanitizeTemplateValue('user@example.com /home/user')).toBe('user@example.com /home/user');
  });
});

// ---------------------------------------------------------------------------
// getCommentStyle
// ---------------------------------------------------------------------------
describe('getCommentStyle', () => {
  it('returns HTML comments for .md', () => {
    expect(getCommentStyle('.md')).toEqual({ start: '<!--', end: '-->' });
  });

  it('returns HTML comments for .mdc', () => {
    expect(getCommentStyle('.mdc')).toEqual({ start: '<!--', end: '-->' });
  });

  it('returns null for .json', () => {
    expect(getCommentStyle('.json')).toBeNull();
  });

  it('returns hash comments for .yaml', () => {
    expect(getCommentStyle('.yaml')).toEqual({ start: '#', end: '' });
  });

  it('returns hash comments for .sh', () => {
    expect(getCommentStyle('.sh')).toEqual({ start: '#', end: '' });
  });

  it('returns hash comments for unknown extensions', () => {
    expect(getCommentStyle('.xyz')).toEqual({ start: '#', end: '' });
  });
});

// ---------------------------------------------------------------------------
// getGeneratedHeader
// ---------------------------------------------------------------------------
describe('getGeneratedHeader', () => {
  it('generates a markdown header', () => {
    const header = getGeneratedHeader('0.1.0', 'my-repo', '.md');
    expect(header).toContain('GENERATED by AgentKit Forge v0.1.0');
    expect(header).toContain('.agentkit/overlays/my-repo');
    expect(header).toContain('pnpm -C .agentkit agentkit:sync');
  });

  it('returns empty string for JSON', () => {
    expect(getGeneratedHeader('0.1.0', 'my-repo', '.json')).toBe('');
  });

  it('generates YAML-style header for .yml', () => {
    const header = getGeneratedHeader('0.1.0', 'my-repo', '.yml');
    expect(header).toContain('# GENERATED by AgentKit Forge v0.1.0');
  });
});

// ---------------------------------------------------------------------------
// mergePermissions
// ---------------------------------------------------------------------------
describe('mergePermissions', () => {
  it('merges allow lists with deduplication', () => {
    const result = mergePermissions(
      { allow: ['Read', 'Write'] },
      { allow: ['Write', 'Bash'] }
    );
    expect(result.allow).toEqual(['Read', 'Write', 'Bash']);
  });

  it('merges deny lists with deduplication', () => {
    const result = mergePermissions(
      { deny: ['Bash'] },
      { deny: ['Bash', 'Write'] }
    );
    expect(result.deny).toEqual(['Bash', 'Write']);
  });

  it('handles empty base', () => {
    const result = mergePermissions({}, { allow: ['Read'], deny: ['Bash'] });
    expect(result.allow).toEqual(['Read']);
    expect(result.deny).toEqual(['Bash']);
  });

  it('handles empty overlay', () => {
    const result = mergePermissions({ allow: ['Read'], deny: ['Bash'] }, {});
    expect(result.allow).toEqual(['Read']);
    expect(result.deny).toEqual(['Bash']);
  });

  it('handles both empty', () => {
    const result = mergePermissions({}, {});
    expect(result.allow).toEqual([]);
    expect(result.deny).toEqual([]);
  });
});

// ---------------------------------------------------------------------------
// insertHeader
// ---------------------------------------------------------------------------
describe('insertHeader', () => {
  it('prepends header to plain content', () => {
    const result = insertHeader('Hello world', '.yml', '0.1.0', 'test');
    expect(result).toMatch(/^# GENERATED by AgentKit Forge/);
    expect(result).toContain('Hello world');
  });

  it('skips if header already present', () => {
    const content = '# GENERATED by AgentKit Forge v0.1.0\nHello';
    const result = insertHeader(content, '.yml', '0.1.0', 'test');
    expect(result).toBe(content);
  });

  it('inserts after shebang in .sh files', () => {
    const content = '#!/usr/bin/env bash\necho "hello"';
    const result = insertHeader(content, '.sh', '0.1.0', 'test');
    expect(result).toMatch(/^#!\/usr\/bin\/env bash\n# GENERATED/);
    expect(result).toContain('echo "hello"');
  });

  it('inserts after frontmatter in .md files', () => {
    const content = '---\ntitle: Test\n---\n# Content';
    const result = insertHeader(content, '.md', '0.1.0', 'test');
    expect(result).toContain('title: Test');
    expect(result).toContain('GENERATED by AgentKit Forge');
    expect(result).toContain('# Content');
  });

  it('returns content unchanged for .json', () => {
    const content = '{"key": "value"}';
    const result = insertHeader(content, '.json', '0.1.0', 'test');
    expect(result).toBe(content);
  });
});

// ---------------------------------------------------------------------------
// isScaffoldOnce
// ---------------------------------------------------------------------------
describe('isScaffoldOnce', () => {
  it('identifies project-owned root files', () => {
    expect(isScaffoldOnce('AGENT_BACKLOG.md')).toBe(true);
    expect(isScaffoldOnce('CHANGELOG.md')).toBe(true);
    expect(isScaffoldOnce('CONTRIBUTING.md')).toBe(true);
    expect(isScaffoldOnce('MIGRATIONS.md')).toBe(true);
    expect(isScaffoldOnce('SECURITY.md')).toBe(true);
  });

  it('identifies editor config files', () => {
    expect(isScaffoldOnce('.editorconfig')).toBe(true);
    expect(isScaffoldOnce('.prettierrc')).toBe(true);
    expect(isScaffoldOnce('.markdownlint.json')).toBe(true);
  });

  it('identifies docs/ directory files', () => {
    expect(isScaffoldOnce('docs/README.md')).toBe(true);
    expect(isScaffoldOnce('docs/01_product/overview.md')).toBe(true);
  });

  it('identifies .vscode/ directory files', () => {
    expect(isScaffoldOnce('.vscode/settings.json')).toBe(true);
    expect(isScaffoldOnce('.vscode/extensions.json')).toBe(true);
  });

  it('identifies GitHub scaffold-once files', () => {
    expect(isScaffoldOnce('.github/PULL_REQUEST_TEMPLATE.md')).toBe(true);
    expect(isScaffoldOnce('.github/copilot-instructions.md')).toBe(true);
    expect(isScaffoldOnce('.github/ISSUE_TEMPLATE/bug_report.md')).toBe(true);
    expect(isScaffoldOnce('.github/instructions/docs.md')).toBe(true);
  });

  it('returns false for always-regenerate AI tool configs', () => {
    expect(isScaffoldOnce('CLAUDE.md')).toBe(false);
    expect(isScaffoldOnce('QUALITY_GATES.md')).toBe(false);
    expect(isScaffoldOnce('UNIFIED_AGENT_TEAMS.md')).toBe(false);
    expect(isScaffoldOnce('.github/workflows/ai-framework-ci.yml')).toBe(false);
  });

  it('returns false for AI tool directories', () => {
    expect(isScaffoldOnce('.claude/settings.json')).toBe(false);
    expect(isScaffoldOnce('.cursor/rules/team-backend.mdc')).toBe(false);
    expect(isScaffoldOnce('.windsurf/rules/team-backend.md')).toBe(false);
  });
});

// ---------------------------------------------------------------------------
// evalTruthy
// ---------------------------------------------------------------------------
describe('evalTruthy', () => {
  it('returns false for undefined', () => {
    expect(evalTruthy(undefined)).toBe(false);
  });

  it('returns false for null', () => {
    expect(evalTruthy(null)).toBe(false);
  });

  it('returns false for false', () => {
    expect(evalTruthy(false)).toBe(false);
  });

  it('returns false for empty string', () => {
    expect(evalTruthy('')).toBe(false);
  });

  it('returns false for 0', () => {
    expect(evalTruthy(0)).toBe(false);
  });

  it('returns false for empty array', () => {
    expect(evalTruthy([])).toBe(false);
  });

  it('returns true for non-empty string', () => {
    expect(evalTruthy('hello')).toBe(true);
  });

  it("returns true for 'none' (use explicit template checks for none values)", () => {
    expect(evalTruthy('none')).toBe(true);
  });

  it('returns true for true', () => {
    expect(evalTruthy(true)).toBe(true);
  });

  it('returns true for positive number', () => {
    expect(evalTruthy(42)).toBe(true);
  });

  it('returns true for non-empty array', () => {
    expect(evalTruthy(['a'])).toBe(true);
  });

  it('returns true for plain object', () => {
    expect(evalTruthy({ key: 'val' })).toBe(true);
  });
});

// ---------------------------------------------------------------------------
// resolveConditionals
// ---------------------------------------------------------------------------
describe('resolveConditionals', () => {
  it('renders truthy branch', () => {
    const result = resolveConditionals('{{#if name}}hello{{/if}}', { name: 'World' });
    expect(result).toBe('hello');
  });

  it('omits falsy block', () => {
    const result = resolveConditionals('{{#if name}}hello{{/if}}', {});
    expect(result).toBe('');
  });

  it('renders else branch when var is falsy', () => {
    const result = resolveConditionals('{{#if flag}}yes{{else}}no{{/if}}', { flag: false });
    expect(result).toBe('no');
  });

  it('renders truthy branch when var is truthy with else', () => {
    const result = resolveConditionals('{{#if flag}}yes{{else}}no{{/if}}', { flag: true });
    expect(result).toBe('yes');
  });

  it('handles nested conditionals', () => {
    const result = resolveConditionals(
      '{{#if outer}}{{#if inner}}both{{else}}outer only{{/if}}{{/if}}',
      { outer: true, inner: false }
    );
    expect(result).toBe('outer only');
  });

  it('uses only the first {{else}} occurrence in a block body', () => {
    // Body has a literal {{else}} that should NOT be treated as a second branch
    const result = resolveConditionals(
      '{{#if flag}}A{{else}}B{{/if}}',
      { flag: true }
    );
    expect(result).toBe('A');

    const result2 = resolveConditionals(
      '{{#if flag}}A{{else}}B{{/if}}',
      { flag: false }
    );
    expect(result2).toBe('B');
  });

  it('preserves surrounding text', () => {
    const result = resolveConditionals('before {{#if x}}X{{/if}} after', { x: 'yes' });
    expect(result).toBe('before X after');
  });

  it('handles multiple independent if blocks', () => {
    const result = resolveConditionals(
      '{{#if a}}A{{/if}}{{#if b}}B{{/if}}',
      { a: true, b: true }
    );
    expect(result).toBe('AB');
  });
});

// ---------------------------------------------------------------------------
// resolveEachBlocks
// ---------------------------------------------------------------------------
describe('resolveEachBlocks', () => {
  it('iterates string arrays replacing {{.}}', () => {
    const result = resolveEachBlocks('{{#each items}}* {{.}}\n{{/each}}', {
      items: ['alpha', 'beta'],
    });
    expect(result).toBe('* alpha\n* beta\n');
  });

  it('returns empty string for empty array', () => {
    const result = resolveEachBlocks('{{#each items}}{{.}}{{/each}}', { items: [] });
    expect(result).toBe('');
  });

  it('returns empty string for undefined var', () => {
    const result = resolveEachBlocks('{{#each items}}{{.}}{{/each}}', {});
    expect(result).toBe('');
  });

  it('iterates object arrays using {{.prop}} syntax', () => {
    const result = resolveEachBlocks('{{#each list}}{{.name}}: {{.purpose}}\n{{/each}}', {
      list: [
        { name: 'Stripe', purpose: 'payments' },
        { name: 'SendGrid', purpose: 'email' },
      ],
    });
    expect(result).toBe('Stripe: payments\nSendGrid: email\n');
  });

  it('replaces {{@index}} with the current index', () => {
    const result = resolveEachBlocks('{{#each items}}{{@index}}:{{.}} {{/each}}', {
      items: ['a', 'b', 'c'],
    });
    expect(result).toBe('0:a 1:b 2:c ');
  });

  it('handles missing object properties gracefully', () => {
    const result = resolveEachBlocks('{{#each list}}{{.name}}{{.missing}}{{/each}}', {
      list: [{ name: 'X' }],
    });
    expect(result).toBe('X');
  });
});

// ---------------------------------------------------------------------------
// flattenProjectYaml
// ---------------------------------------------------------------------------
describe('flattenProjectYaml', () => {
  it('returns empty object for null/undefined input', () => {
    expect(flattenProjectYaml(null)).toEqual({});
    expect(flattenProjectYaml(undefined)).toEqual({});
    expect(flattenProjectYaml('string')).toEqual({});
  });

  it('maps top-level scalars', () => {
    const vars = flattenProjectYaml({ name: 'MyApp', description: 'A desc', phase: 'active' });
    expect(vars.projectName).toBe('MyApp');
    expect(vars.projectDescription).toBe('A desc');
    expect(vars.projectPhase).toBe('active');
  });

  it('joins stack arrays with comma', () => {
    const vars = flattenProjectYaml({
      stack: { languages: ['TypeScript', 'Python'] },
    });
    expect(vars.stackLanguages).toBe('TypeScript, Python');
  });

  it('does not create a meaningful stackLanguages var for empty languages array', () => {
    const vars = flattenProjectYaml({ stack: { languages: [] } });
    // Empty array joins to '' â€” both undefined and '' are falsy for {{#if}} and produce
    // empty output for {{#each}}, so the template behaviour is identical in both cases.
    expect(vars.stackLanguages == null || vars.stackLanguages === '').toBe(true);
  });

  it('handles database as array', () => {
    const vars = flattenProjectYaml({ stack: { database: ['postgres', 'redis'] } });
    expect(vars.stackDatabase).toBe('postgres, redis');
  });

  it('handles database as string (defensive fallback)', () => {
    const vars = flattenProjectYaml({ stack: { database: 'postgres' } });
    expect(vars.stackDatabase).toBe('postgres');
  });

  it('maps architecture fields', () => {
    const vars = flattenProjectYaml({
      architecture: { pattern: 'clean', apiStyle: 'rest', monorepo: true, monorepoTool: 'nx' },
    });
    expect(vars.architecturePattern).toBe('clean');
    expect(vars.architectureApiStyle).toBe('rest');
    expect(vars.hasMonorepo).toBe(true);
    expect(vars.monorepoTool).toBe('nx');
  });

  it('maps documentation boolean has* flags', () => {
    const vars = flattenProjectYaml({
      documentation: { hasPrd: true, prdPath: 'docs/prd.md', hasAdr: false },
    });
    expect(vars.hasPrd).toBe(true);
    expect(vars.prdPath).toBe('docs/prd.md');
    expect(vars.hasAdr).toBe(false);
  });

  it('maps deployment fields', () => {
    const vars = flattenProjectYaml({
      deployment: {
        cloudProvider: 'aws',
        containerized: true,
        environments: ['dev', 'prod'],
        iacTool: 'terraform',
      },
    });
    expect(vars.cloudProvider).toBe('aws');
    expect(vars.hasContainerized).toBe(true);
    expect(vars.environments).toBe('dev, prod');
    expect(vars.iacTool).toBe('terraform');
  });

  it('keeps integrations as array for {{#each}} with hasIntegrations flag', () => {
    const integ = [{ name: 'Stripe', purpose: 'payments' }];
    const vars = flattenProjectYaml({ integrations: integ });
    expect(vars.integrations).toEqual(integ);
    expect(vars.hasIntegrations).toBe(true);
  });

  it('sets hasIntegrations to false for empty integrations array', () => {
    const vars = flattenProjectYaml({ integrations: [] });
    expect(vars.hasIntegrations).toBe(false);
  });
});

// ---------------------------------------------------------------------------
// flattenCrosscutting
// ---------------------------------------------------------------------------
describe('flattenCrosscutting', () => {
  it('returns empty vars for empty crosscutting object', () => {
    const vars = {};
    flattenCrosscutting({}, vars);
    expect(vars.hasLogging).toBeUndefined();
    expect(vars.hasAuth).toBeUndefined();
  });

  it('sets hasLogging and loggingFramework when framework is not none', () => {
    const vars = {};
    flattenCrosscutting({ logging: { framework: 'winston', level: 'debug' } }, vars);
    expect(vars.hasLogging).toBe(true);
    expect(vars.loggingFramework).toBe('winston');
    expect(vars.loggingLevel).toBe('debug');
  });

  it('does not set hasLogging when framework is none', () => {
    const vars = {};
    flattenCrosscutting({ logging: { framework: 'none' } }, vars);
    expect(vars.hasLogging).toBeUndefined();
    expect(vars.loggingFramework).toBeUndefined();
  });

  it('sets hasAuth and authProvider when provider is not none', () => {
    const vars = {};
    flattenCrosscutting({ authentication: { provider: 'auth0', strategy: 'jwt-bearer' } }, vars);
    expect(vars.hasAuth).toBe(true);
    expect(vars.authProvider).toBe('auth0');
    expect(vars.authStrategy).toBe('jwt-bearer');
  });

  it('does not set hasAuth when provider is none', () => {
    const vars = {};
    flattenCrosscutting({ authentication: { provider: 'none' } }, vars);
    expect(vars.hasAuth).toBeUndefined();
  });

  it('sets hasCorrelationId as boolean from logging.correlationId', () => {
    const vars = {};
    flattenCrosscutting({ logging: { correlationId: true } }, vars);
    expect(vars.hasCorrelationId).toBe(true);
  });

  it('sets hasCaching and cachingProvider when provider is not none', () => {
    const vars = {};
    flattenCrosscutting({ caching: { provider: 'redis', patterns: ['cache-aside'] } }, vars);
    expect(vars.hasCaching).toBe(true);
    expect(vars.cachingProvider).toBe('redis');
    expect(vars.cachingPatterns).toBe('cache-aside');
  });

  it('sets hasApiVersioning when versioning is not none', () => {
    const vars = {};
    flattenCrosscutting({ api: { versioning: 'url-segment', pagination: 'cursor' } }, vars);
    expect(vars.hasApiVersioning).toBe(true);
    expect(vars.apiVersioning).toBe('url-segment');
    expect(vars.hasApiPagination).toBe(true);
    expect(vars.apiPagination).toBe('cursor');
  });

  it('sets hasDbMigrations when migrations is not none', () => {
    const vars = {};
    flattenCrosscutting({ database: { migrations: 'code-first' } }, vars);
    expect(vars.hasDbMigrations).toBe(true);
    expect(vars.dbMigrations).toBe('code-first');
  });

  it('sets hasFeatureFlags when provider is not none', () => {
    const vars = {};
    flattenCrosscutting({ featureFlags: { provider: 'launchdarkly' } }, vars);
    expect(vars.hasFeatureFlags).toBe(true);
    expect(vars.featureFlagProvider).toBe('launchdarkly');
  });
});
