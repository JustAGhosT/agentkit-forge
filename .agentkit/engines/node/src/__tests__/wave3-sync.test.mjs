import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { runSync } from '../sync.mjs';
import { mkdirSync, writeFileSync, existsSync, readFileSync, rmSync, readdirSync } from 'fs';
import { resolve, join } from 'path';
import { tmpdir } from 'os';

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

const AGENTKIT_ROOT = resolve(import.meta.dirname, '..', '..', '..', '..');

/** Creates a temp project root for testing sync output. */
function makeTmpProject() {
  const dir = resolve(tmpdir(), `agentkit-wave3-test-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`);
  mkdirSync(dir, { recursive: true });
  return dir;
}

/** Collects all files under a directory recursively (relative paths, forward slashes). */
function collectFiles(dir, base = dir) {
  const results = [];
  if (!existsSync(dir)) return results;
  for (const entry of readdirSync(dir, { withFileTypes: true })) {
    const full = join(dir, entry.name);
    if (entry.isDirectory()) {
      results.push(...collectFiles(full, base));
    } else {
      results.push(full.slice(base.length + 1).replace(/\\/g, '/'));
    }
  }
  return results;
}

// ---------------------------------------------------------------------------
// Tests: Wave 3A — Copilot Prompts
// ---------------------------------------------------------------------------
describe('syncCopilotPrompts (via runSync --only copilot)', () => {
  let projectRoot;

  beforeEach(() => { projectRoot = makeTmpProject(); });
  afterEach(() => { rmSync(projectRoot, { recursive: true, force: true }); });

  it('generates .github/prompts/*.prompt.md for non-team commands', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'copilot' } });
    const files = collectFiles(projectRoot);
    const prompts = files.filter(f => f.startsWith('.github/prompts/'));
    expect(prompts.length).toBeGreaterThan(0);
    // Should have prompt files for workflow/utility commands
    expect(prompts.some(f => f.includes('build.prompt.md'))).toBe(true);
    expect(prompts.some(f => f.includes('check.prompt.md'))).toBe(true);
    // Should NOT have prompt files for team commands
    expect(prompts.some(f => f.includes('team-backend.prompt.md'))).toBe(false);
  });

  it('prompt files contain GENERATED header', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'copilot' } });
    const content = readFileSync(resolve(projectRoot, '.github', 'prompts', 'build.prompt.md'), 'utf-8');
    expect(content).toContain('GENERATED by AgentKit Forge');
  });

  it('prompt files contain frontmatter', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'copilot' } });
    const content = readFileSync(resolve(projectRoot, '.github', 'prompts', 'build.prompt.md'), 'utf-8');
    expect(content).toContain('mode: "agent"');
  });
});

// ---------------------------------------------------------------------------
// Tests: Wave 3A — Copilot Agents
// ---------------------------------------------------------------------------
describe('syncCopilotAgents (via runSync --only copilot)', () => {
  let projectRoot;

  beforeEach(() => { projectRoot = makeTmpProject(); });
  afterEach(() => { rmSync(projectRoot, { recursive: true, force: true }); });

  it('generates .github/agents/*.agent.md from agents.yaml', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'copilot' } });
    const files = collectFiles(projectRoot);
    const agents = files.filter(f => f.startsWith('.github/agents/'));
    expect(agents.length).toBeGreaterThan(0);
    expect(agents.some(f => f.includes('backend.agent.md'))).toBe(true);
    expect(agents.some(f => f.includes('frontend.agent.md'))).toBe(true);
  });

  it('agent files contain agent name and role', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'copilot' } });
    const content = readFileSync(resolve(projectRoot, '.github', 'agents', 'backend.agent.md'), 'utf-8');
    expect(content).toContain('Backend Engineer');
  });
});

// ---------------------------------------------------------------------------
// Tests: Wave 3A — Copilot Chat Modes
// ---------------------------------------------------------------------------
describe('syncCopilotChatModes (via runSync --only copilot)', () => {
  let projectRoot;

  beforeEach(() => { projectRoot = makeTmpProject(); });
  afterEach(() => { rmSync(projectRoot, { recursive: true, force: true }); });

  it('generates .github/chatmodes/team-*.chatmode.md from teams.yaml', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'copilot' } });
    const files = collectFiles(projectRoot);
    const chatmodes = files.filter(f => f.startsWith('.github/chatmodes/'));
    expect(chatmodes.length).toBeGreaterThan(0);
    expect(chatmodes.some(f => f.includes('team-backend.chatmode.md'))).toBe(true);
    expect(chatmodes.some(f => f.includes('team-frontend.chatmode.md'))).toBe(true);
  });

  it('chat mode files contain team focus', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'copilot' } });
    const content = readFileSync(resolve(projectRoot, '.github', 'chatmodes', 'team-backend.chatmode.md'), 'utf-8');
    expect(content).toContain('API, services, core logic');
  });
});

// ---------------------------------------------------------------------------
// Tests: Wave 3A — Gemini
// ---------------------------------------------------------------------------
describe('syncGemini (via runSync --only gemini)', () => {
  let projectRoot;

  beforeEach(() => { projectRoot = makeTmpProject(); });
  afterEach(() => { rmSync(projectRoot, { recursive: true, force: true }); });

  it('generates GEMINI.md at project root', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'gemini' } });
    expect(existsSync(resolve(projectRoot, 'GEMINI.md'))).toBe(true);
  });

  it('generates .gemini/styleguide.md', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'gemini' } });
    expect(existsSync(resolve(projectRoot, '.gemini', 'styleguide.md'))).toBe(true);
  });

  it('generates .gemini/config.yaml', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'gemini' } });
    expect(existsSync(resolve(projectRoot, '.gemini', 'config.yaml'))).toBe(true);
  });

  it('GEMINI.md contains GENERATED header', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'gemini' } });
    const content = readFileSync(resolve(projectRoot, 'GEMINI.md'), 'utf-8');
    expect(content).toContain('GENERATED by AgentKit Forge');
  });

  it('GEMINI.md contains project template vars', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'gemini' } });
    const content = readFileSync(resolve(projectRoot, 'GEMINI.md'), 'utf-8');
    expect(content).toContain('Gemini Instructions');
  });
});

// ---------------------------------------------------------------------------
// Tests: Wave 3A — Codex Skills
// ---------------------------------------------------------------------------
describe('syncCodexSkills (via runSync --only codex)', () => {
  let projectRoot;

  beforeEach(() => { projectRoot = makeTmpProject(); });
  afterEach(() => { rmSync(projectRoot, { recursive: true, force: true }); });

  it('generates .agents/skills/*/SKILL.md for non-team commands', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'codex' } });
    const files = collectFiles(projectRoot);
    const skills = files.filter(f => f.startsWith('.agents/skills/'));
    expect(skills.length).toBeGreaterThan(0);
    expect(skills.some(f => f.includes('build/SKILL.md'))).toBe(true);
    // Should NOT have skills for team commands
    expect(skills.some(f => f.includes('team-backend/SKILL.md'))).toBe(false);
  });

  it('SKILL.md contains command name', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'codex' } });
    const content = readFileSync(resolve(projectRoot, '.agents', 'skills', 'build', 'SKILL.md'), 'utf-8');
    expect(content).toContain('build');
    expect(content).toContain('GENERATED by AgentKit Forge');
  });
});

// ---------------------------------------------------------------------------
// Tests: Wave 3A — Claude Skills
// ---------------------------------------------------------------------------
describe('syncClaudeSkills (via runSync --only claude)', () => {
  let projectRoot;

  beforeEach(() => { projectRoot = makeTmpProject(); });
  afterEach(() => { rmSync(projectRoot, { recursive: true, force: true }); });

  it('generates .claude/skills/*/SKILL.md for non-team commands', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'claude' } });
    const files = collectFiles(projectRoot);
    const skills = files.filter(f => f.startsWith('.claude/skills/'));
    expect(skills.length).toBeGreaterThan(0);
    expect(skills.some(f => f.includes('build/SKILL.md'))).toBe(true);
  });
});

// ---------------------------------------------------------------------------
// Tests: Wave 3B — Cursor Commands
// ---------------------------------------------------------------------------
describe('syncCursorCommands (via runSync --only cursor)', () => {
  let projectRoot;

  beforeEach(() => { projectRoot = makeTmpProject(); });
  afterEach(() => { rmSync(projectRoot, { recursive: true, force: true }); });

  it('generates .cursor/commands/*.md for non-team commands', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'cursor' } });
    const files = collectFiles(projectRoot);
    const commands = files.filter(f => f.startsWith('.cursor/commands/'));
    expect(commands.length).toBeGreaterThan(0);
    expect(commands.some(f => f.includes('build.md'))).toBe(true);
    expect(commands.some(f => f.includes('check.md'))).toBe(true);
    // No team commands
    expect(commands.some(f => f.includes('team-backend.md'))).toBe(false);
  });

  it('cursor command files contain GENERATED header', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'cursor' } });
    const content = readFileSync(resolve(projectRoot, '.cursor', 'commands', 'build.md'), 'utf-8');
    expect(content).toContain('GENERATED by AgentKit Forge');
  });
});

// ---------------------------------------------------------------------------
// Tests: Wave 3B — WARP.md
// ---------------------------------------------------------------------------
describe('syncWarp (via runSync --only warp)', () => {
  let projectRoot;

  beforeEach(() => { projectRoot = makeTmpProject(); });
  afterEach(() => { rmSync(projectRoot, { recursive: true, force: true }); });

  it('generates WARP.md at project root', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'warp' } });
    expect(existsSync(resolve(projectRoot, 'WARP.md'))).toBe(true);
  });

  it('WARP.md contains GENERATED header', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'warp' } });
    const content = readFileSync(resolve(projectRoot, 'WARP.md'), 'utf-8');
    expect(content).toContain('GENERATED by AgentKit Forge');
  });

  it('WARP.md contains Warp Instructions heading', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'warp' } });
    const content = readFileSync(resolve(projectRoot, 'WARP.md'), 'utf-8');
    expect(content).toContain('Warp Instructions');
  });
});

// ---------------------------------------------------------------------------
// Tests: Wave 3C — Cline Rules
// ---------------------------------------------------------------------------
describe('syncClineRules (via runSync --only cline)', () => {
  let projectRoot;

  beforeEach(() => { projectRoot = makeTmpProject(); });
  afterEach(() => { rmSync(projectRoot, { recursive: true, force: true }); });

  it('generates .clinerules/*.md from rules.yaml domains', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'cline' } });
    const files = collectFiles(projectRoot);
    const rules = files.filter(f => f.startsWith('.clinerules/'));
    expect(rules.length).toBeGreaterThan(0);
    expect(rules.some(f => f.includes('typescript.md'))).toBe(true);
    expect(rules.some(f => f.includes('security.md'))).toBe(true);
  });

  it('cline rule files contain domain name and conventions', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'cline' } });
    const content = readFileSync(resolve(projectRoot, '.clinerules', 'typescript.md'), 'utf-8');
    expect(content).toContain('typescript');
    expect(content).toContain('Conventions');
  });
});

// ---------------------------------------------------------------------------
// Tests: Wave 3C — Roo Code Rules
// ---------------------------------------------------------------------------
describe('syncRooRules (via runSync --only roo)', () => {
  let projectRoot;

  beforeEach(() => { projectRoot = makeTmpProject(); });
  afterEach(() => { rmSync(projectRoot, { recursive: true, force: true }); });

  it('generates .roo/rules/*.md from rules.yaml domains', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'roo' } });
    const files = collectFiles(projectRoot);
    const rules = files.filter(f => f.startsWith('.roo/rules/'));
    expect(rules.length).toBeGreaterThan(0);
    expect(rules.some(f => f.includes('typescript.md'))).toBe(true);
    expect(rules.some(f => f.includes('security.md'))).toBe(true);
  });

  it('roo rule files contain GENERATED header', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'roo' } });
    const content = readFileSync(resolve(projectRoot, '.roo', 'rules', 'typescript.md'), 'utf-8');
    expect(content).toContain('GENERATED by AgentKit Forge');
  });
});

// ---------------------------------------------------------------------------
// Tests: Render target gating — new tools excluded when not in targets
// ---------------------------------------------------------------------------
describe('render target gating for new tools', () => {
  let projectRoot;

  beforeEach(() => { projectRoot = makeTmpProject(); });
  afterEach(() => { rmSync(projectRoot, { recursive: true, force: true }); });

  it('--only claude does NOT generate gemini, warp, cline, roo, codex files', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'claude' } });
    const files = collectFiles(projectRoot);
    expect(files.some(f => f === 'GEMINI.md')).toBe(false);
    expect(files.some(f => f === 'WARP.md')).toBe(false);
    expect(files.some(f => f.startsWith('.gemini/'))).toBe(false);
    expect(files.some(f => f.startsWith('.agents/'))).toBe(false);
    expect(files.some(f => f.startsWith('.clinerules/'))).toBe(false);
    expect(files.some(f => f.startsWith('.roo/'))).toBe(false);
  });

  it('always-on outputs generated regardless of --only flag', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'warp' } });
    const files = collectFiles(projectRoot);
    // AGENTS.md is always-on
    expect(files.some(f => f === 'AGENTS.md')).toBe(true);
    // WARP.md is the only gated output
    expect(files.some(f => f === 'WARP.md')).toBe(true);
    // Claude-specific outputs should NOT be present
    expect(files.some(f => f === 'CLAUDE.md')).toBe(false);
    expect(files.some(f => f.startsWith('.claude/'))).toBe(false);
  });
});

// ---------------------------------------------------------------------------
// Tests: Empty-spec edge cases
// ---------------------------------------------------------------------------
describe('empty-spec edge cases', () => {
  let projectRoot;

  beforeEach(() => { projectRoot = makeTmpProject(); });
  afterEach(() => { rmSync(projectRoot, { recursive: true, force: true }); });

  it('no commands → no copilot prompts generated', async () => {
    // Sync with copilot target against real root; commands.yaml has commands,
    // but if we override with empty spec, no prompts should be generated.
    // Instead, we test the gating: syncing with only 'mcp' should NOT produce prompts
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'mcp' } });
    const files = collectFiles(projectRoot);
    const prompts = files.filter(f => f.startsWith('.github/prompts/'));
    expect(prompts.length).toBe(0);
  });

  it('no commands → no cursor commands generated when target is windsurf', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'windsurf' } });
    const files = collectFiles(projectRoot);
    const cursorCmds = files.filter(f => f.startsWith('.cursor/commands/'));
    expect(cursorCmds.length).toBe(0);
  });

  it('no commands → no codex skills generated when target is cline', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'cline' } });
    const files = collectFiles(projectRoot);
    const skills = files.filter(f => f.startsWith('.agents/skills/'));
    expect(skills.length).toBe(0);
  });

  it('no teams → no cursor team rules when target is cursor', async () => {
    // With only 'ai' target, no team-*.mdc should appear
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'ai' } });
    const files = collectFiles(projectRoot);
    const teamRules = files.filter(f => f.startsWith('.cursor/rules/team-'));
    expect(teamRules.length).toBe(0);
  });

  it('no teams → no windsurf team rules when target is codex', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'codex' } });
    const files = collectFiles(projectRoot);
    const teamRules = files.filter(f => f.startsWith('.windsurf/rules/team-'));
    expect(teamRules.length).toBe(0);
  });

  it('no teams → no copilot chatmodes when target is gemini', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'gemini' } });
    const files = collectFiles(projectRoot);
    const chatmodes = files.filter(f => f.startsWith('.github/chatmodes/'));
    expect(chatmodes.length).toBe(0);
  });

  it('no agents → no copilot agent files when target is warp', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'warp' } });
    const files = collectFiles(projectRoot);
    const agents = files.filter(f => f.startsWith('.github/agents/'));
    expect(agents.length).toBe(0);
  });

  it('no agents → no claude agent files when target is roo', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'roo' } });
    const files = collectFiles(projectRoot);
    const agents = files.filter(f => f.startsWith('.claude/agents/'));
    expect(agents.length).toBe(0);
  });

  it('no rules → no cline rules when target is warp', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'warp' } });
    const files = collectFiles(projectRoot);
    const clineRules = files.filter(f => f.startsWith('.clinerules/'));
    expect(clineRules.length).toBe(0);
  });

  it('no rules → no roo rules when target is mcp', async () => {
    await runSync({ agentkitRoot: AGENTKIT_ROOT, projectRoot, flags: { only: 'mcp' } });
    const files = collectFiles(projectRoot);
    const rooRules = files.filter(f => f.startsWith('.roo/rules/'));
    expect(rooRules.length).toBe(0);
  });
});
